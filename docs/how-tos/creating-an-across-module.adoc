# Creating an Across Module

## Structure

The structure of an Across module is very similar to the structure of an Across application, like the ones generated by link:https://start.across.dev/[Across Initializr].
To maintain clarity, we strongly advise you to include _modules_ in the artifact name and end with the name of your module.
e.g. `com.foreach.example.modules.my` is the package of `MyModule`. Under `com.foreach.example.modules.my` we would then typically have the following sub-packages: _config_, _domain_ and _extensions_.

Beans in the _config_ package are automatically picked up and scanned by our module.
This is most often the folder where our global configuration is found as well.
The `DomainConfiguration`class often has an `@EnableAcrossJpaRepositories` annotation to pick up the repositories present in the module.

The _domain_ package typically holds several subfolders in which our domain model is defined in a Domain-Driven Design fashion.
It is often practical to have a marker class to refer to from for example our @EnableAcrossJpaRepositories annotation.

The _extensions_ package is a special one, just like _config_, where we usually put our configuration classes for other modules, a typical example is `AcrossHibernateJpaModule`, for which we configure the packages to scan for entities.
The Across Framework will by default look for `@ModuleConfiguration` classes within the config and extensions sub-packages.

In the end our module structure looks something like this

```
com.foreach.example.modules.my
    | config
     \ DomainConfiguration.java // global configuration
    | domain
     \ DomainMarker.java // marker class for our domain model
    | extensions 
     \ EntityScanConfiguration.java //moduleconfiguration for AcrossHibernateJpaModule
    \ MyModule.java // Module descriptor
```

So what's different with the structure generated by link:https://start.across.dev/[Across Initializr]?
It does not contain the package _modules_, but rather an _application_ package, which holds the above sub-packages and will be automatically scanned for beans.
The _application_ package contains the code for our application module.

## Module descriptor

The module descriptor for our Across module is nothing more than a simple class that extends `AcrossModule`.
`AcrossModule` provides various methods to further customize settings for your module and requires your module to at least implement `getName()`.
Typically we create a `public static final String NAME` which holds our module name.

Aside of the name of our module, we often also define the `@AcrossDepends` annotation, where we can specify which modules are required and which modules are optional to use our new module.
This annotation also ensures that the modules are bootstrapped in the correct order.
This means that modules that our module depends on are bootstrapped before our module is bootstrapped, and modules that depend on our module are bootstrapped afterwards.

As an example, MyModule just defines a simple shared domain model and as such will have repositories, so it would look something like this:

```java
@AcrossDepends(required = {
        AcrossHibernateJpaModule.NAME
})
public class MyModule extends AcrossModule{
    public static final String NAME = "MyModule";

    @Override
    public String getName() {
        return NAME;
    }
}
```

## Beans

As we have noticed earlier, by default the _config_ and _extensions_ packages are scanned for beans.
To be able to scan for other beans, Services for example, we will need to provide additional configuration.
We can do this in two ways, the first one being an `@ComponentScan` annotation, which simply says where should be scanned for components.
Or by overriding the `registerDefaultApplicationContextConfigurers( Set<ApplicationContextConfigurer> contextConfigurers ) `and adding a `ComponentScanConfigurer`.

```java
@Override
protected void registerDefaultApplicationContextConfigurers( Set<ApplicationContextConfigurer> contextConfigurers ) {
    contextConfigurers.add( ComponentScanConfigurer.forAcrossModule( MyModule.class ) );
}
```

The `ComponentScanConfigurer.forAcrossModule` method excludes two packages from being scanned to prevent faulty or unexpected configurations:

* extensions: in the extension package we define configurations that should be injected into _other_ modules
* installers: in the installers package we define our installers.
<<developing-modules.adoc#installers,Installers>> are special beans that will only exist during the application startup.

Since our module will have its own application context, for beans to be visible by other modules they need to be <<developing-modules.adoc#exposing-beans,exposed>>.
By default all beans annotated with `@Exposed` or `@Service` will be exposed to other contexts.
This means that if you define repositories in your module and you want to allow other modules or applications to use them, they will have to be annotated with `@Exposed`.
However if you wish to expose all your repositories without annotating them with `@Exposed`, you can also override the default expose filter.

```java
public MyModule(){
    setExposefilter( new BeanFilterComposite( AcrossModule.defaultExposeFilter(), new ClassBeanFilter( Repository.class ) ) );
}
```

## Tests

For our module to be usable by other modules and applications, it is very important that it works correctly.
Hence you should always provide tests, at the very least a few integration tests to check your module works as intended.
To do so take a look at our <<testing.adoc#across-test,testing section>> for more information about Across Test.

