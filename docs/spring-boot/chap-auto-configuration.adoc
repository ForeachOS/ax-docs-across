== Auto-configuration support

You can use `@AcrossApplication` to execute as a Spring Boot application and use auto-configuration of your application infrastructure.
However not all auto-configuration classes are supported in an Across application.

This section explains why that is and how developers can provide compatibility adapters for existing configurations.

=== Across support explained

:!numbered:
==== The basic challenge

Most Spring related libraries are fine-tuned to easily work in a single Spring `ApplicationContext`.
This is also very much the case with the default Spring Boot auto-configuration classes.

An Across application has a more complex `ApplicationContext` hierarchy:

* every module has its own `ApplicationContext`: *module level*
* the Across context has single `ApplicationContext` that is the parent of all modules: *Across context level*
* in case of executing as Spring Boot (using `@AcrossApplication`) there is an additional `ApplicationContext` that is the parent of the Across context: *application (infrastructure) level*

NOTE: There is a difference between the *application* and the *application module*.
The latter is a single module in the Across context.
Please read the chapter on link:{doc-fundamentals}[Across fundamentals] if you do not clearly understand this difference.

Because of the hierarchy, visibility, dependencies and creation order of beans are more important.
This helps you define clearly dependant modules, but it adds additional complexity compared to a single `ApplicationContext` application.

Default Spring Boot auto-configuration classes only work in the top-level `ApplicationContext`, the application level.
Often we require them to activate behaviour in modules, as such they usually do not work out-of-the-box and need to be adapted.

Across provides some ways to <<adding-support,manually add transparent auto-configuration support>> for Across applications.
This can allow developers to use the same starters and libraries in an Across application, often with no (or very little) difference.

Not every library or auto-configuration works as easily in an Across application.
The Across auto-configure artifact contains compatibility configuration for common starters and libraries, to ease the transition for developers.

For every library/Spring Boot starter mentioned in this document, there are 2 support indicators:

==== Support level

Indicates the level of support in a multi-module Across application.

Not supported::
  No auto-configuration possible.

Full support::
  Virtually no difference compared to a regular Spring Boot application.
  Support is automatic in all modules configured in an application.
  Common case: web controllers, actuator endpoints...

Application support::
  Auto-configuration works as expected for an Across application.
  Infrastructure is usually configured on the application level, automatic support is only activated in the application module.
  Shared modules require manual configuration.
  Common case: Spring Data repositories

Partial support::
  Auto-configuration is partially supported.
  Additional manual configuration is still required.

==== Support status

Indicates the status of the support for that starter/library.
This is more of an indication of the work in progress.

Expected::
  Currently not yet available.

To be verified::
  Auto-configuration available but not yet - or only partially - verified.
  Some cases might not yet work as expected.

Verified::
  Support level is available as indicated.

:numbered:
[[adding-support]]
=== Adding compatibility

When starting a Spring Boot application with `@AcrossApplication` all auto-configuration classes detected will be considered.
If Across is unsure about what to do with them, you should see the AutoConfiguration Report printed in the logs:

[source]
----
 --- Across AutoConfiguration Report ---
 The following auto-configuration classes have unknown Across support and were not added:
 - org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration
 - org.springframework.boot.autoconfigure.aop.AopAutoConfiguration
 Consider adding them to a META-INF/across.configuration.
 --- End Across AutoConfiguration Report ---
----

This gives you an indication of which classes require a compatibility adapter if you want to use them.
Across will skip these auto-configuration classes but will continue bootstrapping.
If you add a compatible configuration in the right way the warning will disappear, see <<across-configuration>>.

NOTE: There is a difference between a not-supported auto-configuration class, and one with unknown support.
The latter should print out the warning in the AutoConfiguration report, the former should be present in an `across.configuration` so the warning disappears.

:!numbered:
[discrete]
==== Auto-configuration problems

The most common problems to solve have to do with where to put the actual auto-configuration class and which components to expose.

* if it only provides components for direct use by other modules (eg. components from the modules want to inject them)
** leave the configuration on application level or move it to a module starting before the modules wishing to use those components
** when moving to a module, expose the components that other modules want to inject
** *IMPORTANT:* if your configuration uses Spring conditionals depending on components defined inside other modules, it can never remain on the application level as those conditions would never match
* if it only uses components provided by other modules
** expose those components in the other modules
** if it does not work when injecting on application level, consider moving to one of the last modules (eg. the <<AcrossContextPostProcessorModule>>
*** this depends on how the components it needs are looked for, if it does not look up the parent `ApplicationContext` it would still not detect exposed beans on the application level
* if it does more than one of the above cases
** you will need to create a custom configuration class

Some auto-configuration classes need to setup infrastructure in more than one module.
In that case you will also need a custom configuration class that injects the required code in the relevant modules (usually all of them in a case like this).

[discrete]
==== AcrossContextPostProcessorModule
Every Across context contains a placeholder module called *AcrossContextPostProcessorModule*.
It usually starts as the very last module, after the application module.
It can be used to move configuration classes to that need to rely on components defined by all other modules.

If no configuration has been added to the module, it will be disabled and not bootstrap.

[[across-configuration]]
==== META-INF/across.configuration
The `across.configuration` file allows you to move auto-configuration, exposed additional beans and provide alternative configuration classes.
Every JAR file can contain a single `across.configuration` and all data from them will be merged together.

As only Across interprets these files, existing libraries can add them to support both Across- and non-Across-based application.
The `across.configuration` should always be located in the `META-INF` folder in the root of your package.

A `across.configuration` is a properties file supporting 3 property keys that can have comma-separated values:

com.foreach.across.Exposed::
 List of class names for components that should always be exposed by every module.
 Class name can be specific or abstract class, interface or annotation.
 In case of an annotation, any component with that annotation will be exposed.

com.foreach.across.AutoConfigurationDisabled::
 List of configuration classes that should be rejected when requested through Spring Boot auto-configuration.
 You will only be able to add these configuration classes directly to your application.

com.foreach.across.AutoConfigurationEnabled::
 List of configuration classes that are allowed when requested through Spring Boot auto-configuration.

The *com.foreach.across.AutoConfigurationEnabled* values support multiple options:

* If only the class name is given, the configuration will be added to the application level as is the default Spring Boot behaviour.
* A replacement class can be specified using *:* after the class name.
In this case the replacement class will be added to the application level instead of the original class.
This is useful for providing an `<<AcrossBootstrapConfigurer>>`.
* A module name can be specified using *->* after the class name.
In this case the configuration will not be added to the application level but to the module specified.
You can use *DynamicApplicationModule* as a placeholder name to indicate the configuration should be added to the application module.

.Example META-INF/across.configuration
[source,properties]
----
#
# Lists the classes (or annotations) of components that should always be exposed
#
com.foreach.across.Exposed=\
  org.springframework.stereotype.Service
#
# List of AutoConfiguration classes that should never be allowed.
# Once a class has been added here, it can only ever be added manually to the application.
#
com.foreach.across.AutoConfigurationDisabled=\
  my.IncompatibleAutoConfiguration
#
#
# List of AutoConfiguration classes that are supported on the application level, these will be allowed unless disabled.
# Optionally an adapter class name or a module target can be specified.
#
com.foreach.across.AutoConfigurationEnabled=\
  my.CompatibleAutoConfiguration,\
  my.ReplacedIncompatibleAutoConfiguration:my.AcrossAnotherIncompatibleAutoConfigurationAdapter,\
  my.ApplicationModuleInjectedAutoConfiguration->DynamicApplicationModule,\
  my.PostProcessorModuleInjectedAutoConfiguration->AcrossContextPostProcessorModule
----

NOTE: Some auto-configuration classes use the `AutoConfigurationPackage` for scanning components.
In an Across application, only the package of the application module is automatically registered as an `AutoConfigurationPackage`.
In a regular Spring Boot application, it would be the package that contains the `@SpringBootApplication` class.

[discrete]
[[AcrossBoostrapConfigurer]]
==== AcrossBootstrapConfigurer
You can implement the `AcrossBootstrapConfigurer` interface to alter the module and Across context configuration that is to be started.
Auto-configuration compatibility adapters often implement this interface to inject the configurations in the relevant modules.

.Example AcrossBootstrapConfigurer
[source,java]
----
@Configuration
public class AcrossWebSocketConfiguration implements AcrossBootstrapConfigurer
{
	@Override
	public void configureModule( ModuleBootstrapConfig moduleConfiguration ) {
	    // always expose WebSocketConfigurer
		moduleConfiguration.expose( WebSocketConfigurer.class );
	}

	@Override
	public void configureContext( AcrossBootstrapConfig contextConfiguration ) {
	    // inject configuration in the last module so it can pick up all WebSocketConfigurer instances
		contextConfiguration.extendModule( CONTEXT_POSTPROCESSOR_MODULE, DelegatingWebSocketConfiguration.class );
	}
}
----

:numbered:
