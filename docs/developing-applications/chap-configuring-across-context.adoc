[#across-application-fundamentals]
=== Fundamentals
When creating an Across application, we create an `*Application` class, which defines which modules should be bootstrapped in our application.
However, Across also expects an application module, which defines the logic that our application needs. The `application` package will define the application module.

Example package structure
[source,indent=0]
----
| java
  | com.examples.my
    | application
    \ MyApplication.java
| resources
  \ views
    | static
      | my
      \ *.js
    \ th
      | my
      \ *.html
----

One notable difference from a typical Across module is that all classes under the `application` package and its subpackages will be scanned for components, instead of the default config and extensions sub-packages.
This means, if we'd for example like to add a controller, we can simply define our class under the application package (or a sub-package) with the correct annotations.

Package structure:
[source,indent=0]
----
| java
  | com.examples.my
    | application
      | web
        \ HelloController.java
    \ MyApplication.java
| resources
  \ views
    | static
      | my
        \ js
          \ main.js
        \ css
          \ main.css
    \ th
      | my
        \ homepage.html
----

Example controller:
[source,java,indent=0]
----
package com.examples.my.application.web

@Controller
public class HelloController{

    @RequestMapping("/")
    public String home(){
        return "th/my/homepage"
    }

}
----

The above controller will be automatically picked up and registered as a bean. As we can see, we've mapped the root path "/" to a static template.
This template will be present under `resources/th/my` folder.

The across framework by default configures resource handlers for the web resources in the static/css/js folders under the resources/views folder.
As well as provides a ThymeleafViewResolver for the resources under the resources/th.


[[enableacrosscontext]]
[#enable-across-context]
=== @EnableAcrossContext
Usually your application will consist of a single `AcrossContext` that is configured in the main Spring `ApplicationContext`.
You can enable the automatic creation of an `AcrossContext` by putting the `@EnableAcrossContext` on any `@Configuration` class.
This will initialize a new `AcrossContext` with the main `ApplicationContext` as parent, look for a <<across-datasource,default datasource bean>> named *acrossDataSource* and then configure modules based on the `@EnableAcrossContext` attribute values.

==== AcrossContext autoconfiguration
By default autoconfiguration of the `AcrossContext` will be enabled.
This implies that all `AcrossModule` beans from the parent `ApplicationContext` will be configured, along with any modules specified by name on `@EnableAcrossContext`.

When autoconfiguration is enabled, packages will be scanned to find valid module classes.
Unless packages are configured manually using the *modulePackages* or *modulePackageClasses* attributes, the _com.foreach.across.modules_ package along with the package of the declaring `@Configuration` class will be scanned.

WARNING: If you use `@EnableAcrossContext` on a top-level class (no package specified), package _modules_ and _com.foreach.across.modules_ will be used for default scanning.

Scanning for modules in itself does not add any modules to the `AcrossContext`.
It simply maps all modules that could be autoconfigured on their unique name.
For a module to be autoconfigurable it should adhere to certain conventions, see the section on <<developing-modules.adoc#creating-an-across-module,creating an Across module>> for more details.

NOTE: The module scanning packages and settings can be controlled through attributes on `@EnableAcrossContext`.

WARNING: A module name should be unique.
If you have more than one module with the same name, the last module scanned will take precedence.

.Minimal example of using @EnableAcrossContext
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
/**
 * Minimal configuration that will attempt to resolve module MyCustomModule:
 * - in the standard modules package (com.foreach.across.modules)
 * - in the package that AppConfiguration belongs to
 *
 * If found, MyCustomModule and its required dependencies will be added to the AcrossContext.
 * If not found, AcrossContext bootstrapping will fail.
 */
@Configuration
@EnableAcrossContext( "MyCustomModule" )
public class AppConfiguration
{
}
----

If you want to customize the module configuration or a module is not autoconfigurable, you can add it as a bean in the parent `ApplicationContext` instead.

.Example adding a module as a bean
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
/**
 * AcrossWebModule is added to the AcrossContext by name.
 *
 * MyCustomModule is added as a bean in the ApplicationContext.
 * Because the bean implements AcrossModule, it will also be added to the AcrossContext.
 *
 * All required dependencies of either module will also be added if they can be found through scanning.
 */
@Configuration
@EnableAcrossContext( AcrossWebModule.NAME )
public class AppConfiguration
{
    @Bean
    public MyCustomModule myCustomModule() {
        return new MyCustomModule();
    }
}
----

As the previous example shows, you can safely combine beans and named module configuration.
Modules are configured in a certain order:

. Modules defined by name on `@EnableAcrossContext`
. Module beans detected in the `ApplicationContext`
. Modules added through <<acrosscontextconfigurer,`AcrossContextConfigurer` instances>>
. Missing module dependencies resolved during bootstrap

If a module with the same name gets added more than once, the last version added will always win.

[[acrosscontextconfigurer]]
[#acrosscontextconfigurer]
==== Customizing the AcrossContext
After initial configuration but before bootstrapping, the configured `AcrossContext` will be delegated to all `AcrossContextConfigurer` beans it can find in the `ApplicationContext`.
This allows for changing any settings before the actual bootstrap happens.

.Example customizing an AcrossContext
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Configuration
@EnableAcrossContext
public class WebConfiguration implements AcrossContextConfigurer
{
	@Bean
	public DataSource acrossDataSource() {
		BasicDataSource dataSource = new BasicDataSource();
		dataSource.setDriverClassName( "org.hsqldb.jdbc.JDBCDriver" );
		dataSource.setUrl( "jdbc:hsqldb:mem:/hsql/testDataSource" );
		dataSource.setUsername( "sa" );
		dataSource.setPassword( "" );

		return dataSource;
	}

	@Override
	public void configure( AcrossContext context ) {
		context.setDevelopmentMode( true );

		context.addModule( new SomeModule() );
	}
}
----

