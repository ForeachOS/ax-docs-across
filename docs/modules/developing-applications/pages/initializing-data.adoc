= Initializing application data

////
* installers
* schema installer
* locking on installers: distributedlockrepository
////

On this page, you'll learn:

* [*] What installers are
* [*] How to create a database schema
* [*] How to create insert default/test data

== Installers

Installers are a special type of bean annotated with the `@Installer` annotation.
During the start-up phase of the application, the installers will be created and executed by Across, and afterwards will no longer be available in the application.
This allows developers to initialize data for their applications, for example to create test data or database tables, or to simply insert data in to the database on startup.

=== Creating a database schema

Let's start of with a simple example where we create a simple database table with liquibase.

To do so, first we'll need to create an xml file in which we define liquibase changesets to create a table.
The xml file should be placed in the resources directory of the project.
As good practice, it is advised to place it in a folder named *installers*.

.Example liquibase database changelog
```
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
		xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd">

	<property name="table.user" value="table_user"/> # <1>

	<changeSet id="201805231424" author="stg"> # <2>
		<preConditions onFail="MARK_RAN"> # <3>
			<not>
				<tableExists tableName="${table.user}"/>
			</not>
		</preConditions>

		<comment>Creates user table</comment> # <4>

		<createTable tableName="${table.user}"> # <5>
			<column name="id" type="java.sql.Types.BIGINT">
				<constraints nullable="false" primaryKey="true" primaryKeyName="pk_tbl_user"/>
			</column>
			<column name="first_name" type="java.sql.Types.NVARCHAR(255)">
			    <constraints nullable="false"/>
			</column>
			<column name="last_name" type="java.sql.Types.NVARCHAR(255)">
                <constraints nullable="false"/>
            </column>
			<column name="email" type="java.sql.Types.NVARCHAR(255)">
				<constraints nullable="false"/>
			</column>
			<column name="date_of_birth" type="java.sql.Types.DATE"/>
			<column name="phone_number" type="java.sql.Types.NVARCHAR(255)"/>
		</createTable>
	</changeSet>
</databaseChangeLog>
```
<1> Definition of global properties to be used within the changesets.
Properties are replaced by their value during execution.
<2> A changeset is defined.
Changesets always require a unique identifier and an author.
<3> Preconditions are defined as to when the changeset should be executed.
In this example, we check for the existence of the user table.
Should the table exist, then it does not have to be created and this changeset may be marked as ran.
<4> Optionally, a comment can be added to further describe what the changeset does.
<5> A create table statement is defined.

Through the use of an installer, we can now execute the aforementioned liquibase script when the application is started.
Let's add an installer to the project.
To do so, we'll add an installer to the *installers* package under the *application* package

.Example database schema installer
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Order(1) # <1>
@Installer(name = "schema-installer", runCondition = InstallerRunCondition.VersionDifferent, description = "Installs the required database tables", version = 1) # <2>
public class SchemaInstaller extends AcrossLiquibaseInstaller # <3>
{
	public SchemaInstaller() {
		super( "classpath:installers/demo/schema/main.xml" ); # <4>
	}
}
----
<1> Installers are executed in the order they are picked up.
An explicit ordering can be defined using the `@Order` annotation.
<2> The `@Installer` annotation is present and various parameters are defined.
This means that it can be found by Across and executed during the startup phase.
The `runCondition` parameter defines whether the installer should *always* be executed, or only *when necessary* (e.g. through versioning)
<3> For ease of use, a `AcrossLiquibaseInstaller` class has been defined.
This is a base class for Installers to execute liquibase changelog scripts based on a given xml file.
<4> Define the path to the xml file that contains the liquibase changelog script.

When we now start up our application, the installer is automatically picked up by across and executed.

.Abbreviated logging output during application startup
----
...
INFO --- [ost-startStop-1] f.a.c.i.AcrossBootstrapInstallerRegistry : Executing installer schema-installer for module DemoApplicationModule # <1>
INFO --- [ost-startStop-1] liquibase                                : Successfully acquired change log lock
INFO --- [ost-startStop-1] liquibase                                : Reading from PUBLIC.DATABASECHANGELOG
INFO --- [ost-startStop-1] liquibase                                : classpath:installers/demo/schema/main.xml: classpath:installers/demo/schema/main.xml::201805231424::stg: Table table_user created
INFO --- [ost-startStop-1] liquibase                                : classpath:installers/demo/schema/main.xml: classpath:installers/demo/schema</main.xml::201805231424::stg: ChangeSet classpath:installers/demo/schema/main.xml::201805231424::stg ran successfully in 8ms
...
----
<1> The schema installer is executed.

This can also quickly be checked through the h2-console, where the users table can be found.
In addition to the users table, other tables have been created as well.

image::h2-console-table-user.png[User table is present in h2-console]

Installer execution is tracked to ensure that installers are only run if they have not yet been executed, which is specified through the `runCondition` and `version` parameters.
Tracking is done by the AcrossInstallerRepository, which can also be wired as a bean in installers.
This could be helpful in migration trajectories for example to rename installers.

Aside of tracking, execution is also synchronized for when multiple applications would connect to the same database through the use of a xref:initializing-data#distributed-lock-repository[DistributedLockRepository] that is created in the core schema.
A lock will be taken on the database as soon as a single installer wishes to execute, and will be released once that installer has finished executing.
The lock owner will contain the hostname of the computer running the application, as well as the displayName of the AcrossContext.
Because of tracking and synchronization, a datasource is required in order to execute installers.

=== Installing default or test data

As mentioned, installers are spring beans that only exist during the bootstrap phase of the application.
This means that we can wire other beans directly into this component, and thus, interact with those beans.

This means that we can also define installers that simply insert data into the database.
Let's insert a default admin user in the table that we've created in the section above.

To do so, we'll require a domain model, the User class, and a corresponding repository, the UserRepository.
We'll be using spring to map our entity to the database model, as such we'll add a dependency on the Spring boot JPA starter.

.Abbreviated pom.xml dependencies
[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
    ...
    <dependencies>
        ...
      <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId> # <1>
        </dependency>
    </dependencies>
    ...
----
<1> Dependency to the Spring Data JPA starter.
Note that we do not have to specify a version, because transitively across has a dependency on the Spring boot dependencies pom through on the Spring platform dependency.

.Example User class
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Entity # <1>
@Table(name = "table_user") # <1>
@Data # <2>
@Builder # <3>
public class User implements Persistable<Long> { # <4>
    @Id # <5>
    @GeneratedValue
    private Long id;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "last_name")
    private String lastName;

    @Column
    private String email;

    @Column(name = "date_of_birth")
    private LocalDate dateOfBirth;

    @Column(name = "phone_number")
    private String phoneNumber;

    @Override
    public boolean isNew() { # <4>
        return id == null || id == 0L;
    }
}
----
<1> `@Table` and `@Entity` are annotations used for persistence.
<2> `@Data` will generate various methods to make our class more compact.
Amongst these methods are a constructor, getters and setters.
<3> `@Builder` enables the use of a fluent api to construct the entity.
<4> Spring data JPA is used, as such the `Persistable` interface must be implemented to allow our entity to be fetched using a typed identifier.
Persistable itself requires that `getId()` and `isNew()` are implemented.
`isNew()` is used to check whether the entity has already been persisted.

.Example UserRepository class
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
public interface UserRepository extends JpaRepository<User, Long> { # <1>
}
----
<1> By extending `JpaRepository`, which is a specification of the `Repository` marker interface, Spring is able to automatically detect and create repository beans.
See link:https://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/reference/html/repositories.html[Working with spring data repositories] and link:https://docs.spring.io/spring-data/jpa/docs/1.4.3.RELEASE/reference/html/jpa.repositories.html[JPArepositories] to learn more about the options they provide.

Now that we've created a domain entity and a repository, let's create an installer and insert data into the database.

.Example User data installer
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@Installer(name = "user-installer", description = "Example installer that creates a user", phase = InstallerPhase.AfterContextBootstrap) # <1>
public class UserInstaller {
    @InstallerMethod # <2>
    public void createDefaultUser(UserRepository userRepository) { # <3>
        User user = User.builder().firstName( "John" )
                .lastName( "Doe" )
                .email( "john.doe@local" )
                .dateOfBirth( LocalDate.of( 1990, 3, 24 ) )
                .build();
        userRepository.save( user ); # <4>
    }
}
----
<1> The `@Installer` annotation is provided so that the installer can be found and executed by Across.
This time around, an additional parameter has been added, being `phase`.
`phase` enables the developer to define during which bootstrap phase the installer should be executed.
The default phase is `InstallerPhase.BeforeContextBootstrap` which ensures that installers are executed before any modules are bootstrapped.
This allows installers to be executed before beans are created and is usually used to create database schemas.
`InstallerPhase.AfterContextBootstrap` ensures that all modules have been fully bootstrapped and are ready to be used.
<2> `@InstallerMethod` is added to denote which methods of the installer should be executed.
By using the `@Order` annotation a specific ordering can be defined for the `@InstallerMethods` that are present.
<3> Beans are automatically wired when specifying them as a method parameter.
By setting the `required` parameter on the `@InstallerMethod` annotation, execution will continue even if no bean can be found for a given parameter.
<4> The defined user is persisted using the `JpaRepository` that was defined earlier.



// TODO distributedlockrepository
// other base installers?

[[distributed-lock-repository]]
=== DistributedLockRepository

////
In addition, installer execution is synchronized for multiple applications connecting on the same database. This is done through the DistributedLockRepository that is created in the core schema. A lock will be taken on the database as soon as a single installer wishes to execute, and will be released once that installer has finished executing.

The lock owner will contain the hostname of the computer running the application, as well as the displayName of the AcrossContext.

Because of tracking and synchronization, a datasource is required in order to execute installers.

The AcrossInstallerRepository can be wired as a bean in installers. This can be helpful in migration trajectories for example to rename installers.
////
