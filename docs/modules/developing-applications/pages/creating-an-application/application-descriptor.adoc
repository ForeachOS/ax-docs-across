= Across Application Descriptor

[[across-application]]
[#across-application]
== @AcrossApplication
`@AcrossApplication` annotation can be used as an alternative for `@EnableAcrossContext` and `@SpringBootApplication` when defining an application.
In addition to default context configuration options, it also adds selected <<spring-boot.adoc#spring-boot,Spring Boot autoconfiguration classes>> and enables <<dynamic-across-modules,dynamic modules>>.

Using `@AcrossApplication` is probably the easiest way to setup a simple (Spring Boot based) application backed by an AcrossContext.

WARNING: Using `@EnableAutoConfiguration` and Spring Boot starters directly with Across is currently not supported.
Only a selected number of starters have support directly built into Across.
See <<spring-boot.adoc#spring-boot,Auto-configuration support>> for more background information.
It is also possible to disable specific autoconfiguration classes using the *exclude* attribute on @AcrossApplication.

[[embedded-servlet-container]]
=== Embedded servlet container
Using `@AcrossApplication` adds the necessary Spring Boot auto configuration classes for embedded servlet containers.
If you have for example *spring-boot-starter-tomcat* on the classpath, you can run an Across based application inside an embedded Tomcat using `SpringApplication`.

.Minimal example of a Spring Boot based Across application
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
@AcrossApplication(modules = { MyModule.NAME, MyOtherModule.NAME })
public class MyApplication
{
	public static void main( String[] args ) {
		SpringApplication.run( MyApplication.class, args );
	}
}
----

[[enableacrosscontext]]
[#enable-across-context]
== @EnableAcrossContext
Usually your application will consist of a single `AcrossContext` that is configured in the main Spring `ApplicationContext`.
You can enable the automatic creation of an `AcrossContext` by putting the `@EnableAcrossContext` on any `@Configuration` class.
This will initialize a new `AcrossContext` with the main `ApplicationContext` as parent, look for a <<across-datasource,default datasource bean>> named *acrossDataSource* and then configure modules based on the `@EnableAcrossContext` attribute values.

=== AcrossContext autoconfiguration
By default autoconfiguration of the `AcrossContext` will be enabled.
This implies that all `AcrossModule` beans from the parent `ApplicationContext` will be configured, along with any modules specified by name on `@EnableAcrossContext`.

When autoconfiguration is enabled, packages will be scanned to find valid module classes.
Unless packages are configured manually using the *modulePackages* or *modulePackageClasses* attributes, the _com.foreach.across.modules_ package along with the package of the declaring `@Configuration` class will be scanned.

WARNING: If you use `@EnableAcrossContext` on a top-level class (no package specified), package _modules_ and _com.foreach.across.modules_ will be used for default scanning.

Scanning for modules in itself does not add any modules to the `AcrossContext`.
It simply maps all modules that could be autoconfigured on their unique name.
For a module to be autoconfigurable it should adhere to certain conventions, see the section on <<developing-modules.adoc#creating-an-across-module,creating an Across module>> for more details.

NOTE: The module scanning packages and settings can be controlled through attributes on `@EnableAcrossContext`.

WARNING: A module name should be unique.
If you have more than one module with the same name, the last module scanned will take precedence.

.Minimal example of using @EnableAcrossContext
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
/**
 * Minimal configuration that will attempt to resolve module MyCustomModule:
 * - in the standard modules package (com.foreach.across.modules)
 * - in the package that AppConfiguration belongs to
 *
 * If found, MyCustomModule and its required dependencies will be added to the AcrossContext.
 * If not found, AcrossContext bootstrapping will fail.
 */
@Configuration
@EnableAcrossContext( "MyCustomModule" )
public class AppConfiguration
{
}
----

If you want to customize the module configuration or a module is not autoconfigurable, you can add it as a bean in the parent `ApplicationContext` instead.

.Example adding a module as a bean
[source,java,indent=0]
[subs="verbatim,quotes,attributes"]
----
/**
 * AcrossWebModule is added to the AcrossContext by name.
 *
 * MyCustomModule is added as a bean in the ApplicationContext.
 * Because the bean implements AcrossModule, it will also be added to the AcrossContext.
 *
 * All required dependencies of either module will also be added if they can be found through scanning.
 */
@Configuration
@EnableAcrossContext( AcrossWebModule.NAME )
public class AppConfiguration
{
    @Bean
    public MyCustomModule myCustomModule() {
        return new MyCustomModule();
    }
}
----

As the previous example shows, you can safely combine beans and named module configuration.
Modules are configured in a certain order:

. Modules defined by name on `@EnableAcrossContext`
. Module beans detected in the `ApplicationContext`
. Modules added through <<acrosscontextconfigurer,`AcrossContextConfigurer` instances>>
. Missing module dependencies resolved during bootstrap

If a module with the same name gets added more than once, the last version added will always win.
